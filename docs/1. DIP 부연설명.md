# DIP (Dependency Inversion Principle) 부연 설명

## 개요

DIP의 핵심은 인터페이스를 어디에 두느냐.<br>
상위 모듈이 하위 모듈에 의존하지 않고, `하위 모듈이 상위 모듈의 인터페이스를 구현하도록` 만드는 것.

## 현재 프로젝트 구조 (DIP 적용)

```
payment/
  ├── PaymentService (정책/비즈니스 로직)
  ├── Payment
  └── ExRateProvider (인터페이스)

exRate/
  ├── WebApiExRateProvider (구현체)
  ├── CachedExRateProvider (구현체)
  └── FixedExRateProvider (구현체)
```

## DIP 적용 vs 미적용 비교

### DIP 적용 (현재)
```
payment (상위) ← exRate (하위)
```
- `PaymentService`는 `payment` 패키지만 의존
- `exRate` 패키지가 `payment` 패키지를 의존 (인터페이스 구현)
- **의존성 방향이 역전됨**

### DIP 미적용
```
payment (상위) → exRate (하위)
```
- `PaymentService`가 `exRate` 패키지를 의존
- 하위 모듈이 변경되면 상위 모듈도 영향 받음
- 전통적인 의존성 방향



## 실질적인 차이점

### 1. 패키지 독립성

**DIP 적용**:
```java
package payment;

public class PaymentService {
    private final ExRateProvider provider; // 같은 패키지의 인터페이스
}
```
- payment 패키지만 가져가면 컴파일 가능
- 다른 프로젝트에서도 독립적으로 사용 가능

**DIP 미적용**:
```java
package payment;
import exRate.ExRateProvider; // 외부 패키지 의존

public class PaymentService {
    private final ExRateProvider provider;
}
```
- exRate 패키지 없이는 컴파일 불가
- 불필요한 의존성 증가

### 2. 확장성

**새로운 환율 제공자 추가 시**

**DIP 적용**:
```java
// payment 패키지는 전혀 건드릴 필요 없음
package newExRate;
import payment.ExRateProvider; // payment 인터페이스 구현

public class NewExRateProvider implements ExRateProvider {
    @Override
    public BigDecimal getExRate(String currency) {
        // 새로운 구현
    }
}
```

**DIP 미적용**:
- exRate 패키지에 새 클래스 추가해야 함
- exRate 패키지를 소유하지 않으면 추가 불가능

### 3. 테스트 용이성

**DIP 적용**:
```java
// 테스트 코드에서 간단한 Mock 구현 가능
class TestExRateProvider implements ExRateProvider {
    @Override
    public BigDecimal getExRate(String currency) {
        return BigDecimal.valueOf(1000);
    }
}

PaymentService service = new PaymentService(new TestExRateProvider());
```

## 시나리오

### 시나리오 1: 회사가 커져서 payment 팀과 exRate 팀으로 분리

```
DIP 적용:
payment 팀은 자기 코드만 관리
exRate 팀이 사라져도 payment 모듈은 독립적으로 동작 가능
새로운 exRate 구현체를 다른 팀이 자유롭게 추가 가능

DIP 미적용:
payment가 exRate에 의존하므로 exRate 팀과 계속 협업 필요
exRate 변경 시 payment도 영향 받음
```

### 시나리오 2: payment 로직을 다른 프로젝트에서 재사용하고 싶다

```
DIP 적용:
payment 패키지만 복사하면 됨
새 프로젝트에서 자기만의 ExRateProvider 구현 가능
최소한의 의존성으로 재사용

DIP 미적용:
exRate 패키지도 함께 가져와야 함
불필요한 구현체들도 모두 포함
의존성 복잡도 증가
```

### 시나리오 3: 환율 API를 변경해야 하는 상황

```
DIP 적용:
exRate 패키지에서 새 구현체만 추가
PaymentService는 코드 변경 없음
설정(ObjectFactory)만 수정

DIP 미적용:
같은 작업이지만 심리적으로 payment가 exRate에 종속된 느낌
패키지 구조가 의존 관계를 명확히 표현하지 못함
```

## 핵심 원칙

> **상위 정책(payment)이 하위 세부사항(exRate)에 끌려다니지 않고,**
> **하위가 상위의 규칙을 따르게 만드는 것**



## 선택의 척도

### 인터페이스를 상위 모듈에 둬야 할 때:
- 해당 인터페이스가 "상위 모듈의 요구사항"을 나타낼 때
- 여러 하위 구현체가 존재할 가능성이 있을 때
- 상위 모듈을 독립적으로 재사용하고 싶을 때

### 인터페이스를 하위 모듈에 둬도 되는 때:
- 단순한 유틸리티 라이브러리
- 구현체가 하나뿐이고 추가될 가능성이 없을 때
- 모듈 간 명확한 상하 관계가 없을 때