# 도메인 오브젝트 테스트

## 개요

도메인 오브젝트 테스트는 비즈니스 로직과 규칙을 담고 있는 핵심 객체를 검증하는 테스트다. 외부 의존성 없이 순수한 Java 로직만을 테스트하기 때문에 빠르고 안정적이며, 테스트 피라미드의 가장 하단에 위치하는 가장 기본적이면서도 중요한 테스트 유형이다.

## 도메인 오브젝트란?

도메인 오브젝트(Domain Object)는 비즈니스 로직과 규칙을 담고 있는 핵심 객체를 의미한다.

### 특징
- 비즈니스 로직을 캡슐화한다
- 순수한 Java 객체(POJO)로 구성된다
- JPA의 `@Entity`가 될 수 있지만, 필수는 아니다
- 외부 의존성(DB, 프레임워크 등)이 없다

### 예시

```java
public class Payment {
    private final Long orderId;
    private final String currency;
    private final BigDecimal foreignCurrencyAmount;
    private final BigDecimal exRate;
    private final BigDecimal convertedAmount;
    private final LocalDateTime validUntil;

    // 비즈니스 로직 1: 준비 상태의 Payment 생성
    public static Payment createPrepared(Long orderId, String currency,
                                        BigDecimal foreignCurrencyAmount,
                                        BigDecimal exRate, LocalDateTime now) {
        BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
        LocalDateTime validUntil = now.plusMinutes(30);
        return new Payment(orderId, currency, foreignCurrencyAmount,
                          exRate, convertedAmount, validUntil);
    }

    // 비즈니스 로직 2: 유효성 검증
    public boolean isValid(Clock clock) {
        return LocalDateTime.now(clock).isBefore(this.validUntil);
    }
}
```

## 테스트 피라미드에서의 위치

```
        /\
       /  \
      / UI \          ← E2E 테스트 (느림, 비싸고 깨지기 쉬움)
     /------\
    / 통합   \         ← 통합 테스트 (중간 속도, DB/외부 의존성)
   /----------\
  / 단위 테스트 \      ← 도메인 오브젝트 테스트 (빠름, 안정적)
 /--------------\
```

도메인 오브젝트 테스트는 피라미드의 **가장 아래 부분**에 위치하며, **가장 많은 비중**을 차지해야 한다.

### 권장 비율 (Martin Fowler)

```
도메인 오브젝트 테스트: 70%
단위 테스트 (Stub):    20%
통합 테스트:           10%
E2E 테스트:            <5%
```

## 프로젝트의 테스트 계층 구조

현재 프로젝트에서는 3가지 레벨의 테스트가 존재한다.

### 1. 도메인 오브젝트 테스트 (PaymentTest)

```java
class PaymentTest {
    @Test
    @DisplayName("Payment 도메인 오브젝트 테스트 - 금액 변환, 만료 시간")
    void createPrepared() {
        Clock clock = Clock.fixed(Instant.now(), ZoneId.systemDefault());

        Payment payment = Payment.createPrepared(
            1L, "USD",
            BigDecimal.valueOf(100),
            BigDecimal.valueOf(100),
            LocalDateTime.now(clock)
        );

        assertThat(payment.getConvertedAmount())
            .isEqualByComparingTo(BigDecimal.valueOf(10000));
        assertThat(payment.getValidUntil())
            .isEqualTo(LocalDateTime.now(clock).plusMinutes(30));
    }
}
```

**특징**:
- Payment 객체 자체의 로직만 테스트
- 외부 의존성 없음 (DB, Spring 등)
- 실행 속도가 매우 빠름 (밀리초 단위)
- 테스트가 깨질 가능성이 낮음

### 2. 단위 테스트 (PaymentServiceTest)

```java
class PaymentServiceTest {
    private Clock clock;
    private PaymentService paymentService;

    @BeforeEach
    void setUp() {
        this.clock = Clock.fixed(Instant.now(), ZoneId.systemDefault());
        this.paymentService = new PaymentService(
            new ExRateProviderStub(BigDecimal.valueOf(100)),
            this.clock
        );
    }

    @Test
    @DisplayName("환율 100원으로 다양한 금액 변환 검증")
    void convertWithFixedExRate() throws IOException {
        Payment payment1 = paymentService.prepare(1L, "USD", new BigDecimal(100));
        assertConvertedAmount(payment1, BigDecimal.valueOf(100), BigDecimal.valueOf(10000));
    }
}
```

**특징**:
- PaymentService 로직 테스트
- ExRateProviderStub, Clock 등 목 객체 사용
- 외부 의존성을 제거하여 빠른 테스트
- Spring 컨텍스트 없이 실행

### 3. 통합 테스트 (SpringPaymentServiceTest)

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = TestPaymentConfig.class)
class SpringPaymentServiceTest {
    @Autowired PaymentService paymentService;
    @Autowired ExRateProviderStub exRateProviderStub;
    @Autowired Clock clock;

    @Test
    @DisplayName("환율 변경에 따른 금액 변환 테스트")
    void prepare() throws IOException {
        Payment payment = paymentService.prepare(1L, "USD", new BigDecimal(100));
        assertPaymentAmount(payment, valueOf(100), valueOf(10000));

        exRateProviderStub.setExRate(valueOf(500));
        Payment payment2 = paymentService.prepare(1L, "USD", new BigDecimal(100));
        assertPaymentAmount(payment2, valueOf(500), valueOf(50000));
    }
}
```

**특징**:
- Spring Bean 통합 테스트
- @Autowired, @ExtendWith 사용
- Spring 컨텍스트 로딩 필요
- 상대적으로 무겁고 느림 (초 단위)

## 도메인 오브젝트 테스트의 중요성

### 1. 비즈니스 로직의 순수성 검증

도메인 오브젝트의 비즈니스 로직은 순수한 계산과 검증만을 수행한다.

```java
// 순수한 비즈니스 로직
public static Payment createPrepared(...) {
    BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);  // 계산
    LocalDateTime validUntil = now.plusMinutes(30);                       // 계산
    return new Payment(...);
}

public boolean isValid(Clock clock) {
    return LocalDateTime.now(clock).isBefore(this.validUntil);           // 검증
}
```

이러한 로직은:
- DB가 필요 없다
- Spring 컨텍스트가 필요 없다
- 외부 API가 필요 없다
- 네트워크 연결이 필요 없다

따라서 **순수 Java 로직만 테스트**하면 충분하다.

### 2. 빠른 피드백

```java
// 통합 테스트만 있는 경우
@ExtendWith(SpringExtension.class)  // Spring 컨텍스트 로딩: 5초
@ContextConfiguration(...)          // Bean 생성: 3초
class SpringPaymentServiceTest {
    @Autowired PaymentService service;  // DB 연결: 2초

    @Test
    void test() {
        // 총 10초 이상 소요
    }
}

// 도메인 오브젝트 테스트
class PaymentTest {
    @Test
    void createPrepared() {
        Payment payment = Payment.createPrepared(...);  // 0.01초
        assertThat(payment.getConvertedAmount())...
    }
}
```

**성능 비교**:
- 도메인 테스트: **밀리초 단위**
- 통합 테스트: **초 단위**

개발 중 수백 번 실행하는 테스트의 속도는 생산성에 직접적인 영향을 미친다.

### 3. 리팩토링 안전망

도메인 로직 변경 시 도메인 테스트만 수정하면 된다.

```java
// 요구사항 변경: 유효시간 30분 → 1시간
public static Payment createPrepared(...) {
    LocalDateTime validUntil = now.plusHours(1);  // ← 변경
    return new Payment(...);
}
```

**영향 범위**:
- PaymentTest 수정 (도메인 테스트)
- Spring 설정 변경 불필요
- DB 스키마 변경 불필요
- 통합 테스트 구조 변경 불필요

### 4. 설계 품질 향상

도메인 테스트를 작성하다 보면 자연스럽게 테스트 가능한 설계가 된다.

```java
// 나쁜 설계 (테스트 불가능)
public class Payment {
    public Payment(Long orderId, String currency, BigDecimal amount, BigDecimal exRate) {
        this.orderId = orderId;
        this.currency = currency;
        this.amount = amount;
        this.exRate = exRate;
        this.convertedAmount = amount.multiply(exRate);
        // 문제: 현재 시간에 의존 → 테스트 불가능
        this.validUntil = LocalDateTime.now().plusMinutes(30);
    }
}

// 좋은 설계 (테스트 가능)
public class Payment {
    private Payment(...) { }

    public static Payment createPrepared(..., LocalDateTime now) {
        LocalDateTime validUntil = now.plusMinutes(30);  // 시간 주입 가능
        return new Payment(...);
    }
}
```

**개선 효과**:
- 외부 의존성을 주입받는 구조로 변경
- 테스트에서 시간을 제어 가능
- 순수 함수에 가까운 설계

### 5. 문서화 효과

도메인 테스트는 해당 객체의 사용법과 비즈니스 규칙을 명확히 보여준다.

```java
@Test
@DisplayName("Payment 도메인 오브젝트 테스트 - 금액 변환, 만료 시간")
void createPrepared() {
    // Given: 환율 100원, 100달러
    Clock clock = Clock.fixed(Instant.now(), ZoneId.systemDefault());

    // When: Payment 생성
    Payment payment = Payment.createPrepared(
        1L, "USD",
        BigDecimal.valueOf(100),  // 100달러
        BigDecimal.valueOf(100),  // 환율 100원
        LocalDateTime.now(clock)
    );

    // Then: 10,000원으로 변환, 30분 뒤 만료
    assertThat(payment.getConvertedAmount())
        .isEqualByComparingTo(BigDecimal.valueOf(10000));
    assertThat(payment.getValidUntil())
        .isEqualTo(LocalDateTime.now(clock).plusMinutes(30));
}
```

테스트 코드를 읽으면:
- Payment가 어떻게 생성되는지
- 어떤 비즈니스 규칙이 적용되는지
- 예상되는 결과가 무엇인지

를 명확히 알 수 있다.

## 필수 테스트 항목

도메인 오브젝트에서 "최소한" 작성해야 할 테스트는 다음과 같다.

### 1. 핵심 비즈니스 로직

```java
@Test
@DisplayName("금액 변환 로직 검증")
void convertAmount() {
    Payment payment = Payment.createPrepared(
        1L, "USD",
        BigDecimal.valueOf(100),
        BigDecimal.valueOf(1000),
        LocalDateTime.now()
    );

    assertThat(payment.getConvertedAmount())
        .isEqualByComparingTo(BigDecimal.valueOf(100000));
}
```

### 2. 유효성 검증 로직

```java
@Test
@DisplayName("유효 시간 검증")
void isValid() {
    Clock clock = Clock.fixed(Instant.now(), ZoneId.systemDefault());
    Payment payment = Payment.createPrepared(1L, "USD",
        BigDecimal.valueOf(100), BigDecimal.valueOf(100),
        LocalDateTime.now(clock));

    // 현재 시간: 유효함
    assertThat(payment.isValid(clock)).isTrue();

    // 30분 후: 유효하지 않음
    Clock futureTime = Clock.offset(clock, Duration.ofMinutes(30));
    assertThat(payment.isValid(futureTime)).isFalse();
}
```

### 3. 엣지 케이스

```java
@Test
@DisplayName("음수 금액 예외 처리")
void negativeAmount() {
    assertThatThrownBy(() ->
        Payment.createPrepared(1L, "USD",
            BigDecimal.valueOf(-100),  // 음수
            BigDecimal.valueOf(1000),
            LocalDateTime.now())
    ).isInstanceOf(IllegalArgumentException.class);
}

@Test
@DisplayName("null 파라미터 예외 처리")
void nullParameter() {
    assertThatThrownBy(() ->
        Payment.createPrepared(null, "USD",  // null orderId
            BigDecimal.valueOf(100),
            BigDecimal.valueOf(1000),
            LocalDateTime.now())
    ).isInstanceOf(IllegalArgumentException.class);
}
```

### 4. 경계값 테스트

```java
@Test
@DisplayName("0원 금액 처리")
void zeroAmount() {
    Payment payment = Payment.createPrepared(1L, "USD",
        BigDecimal.ZERO,
        BigDecimal.valueOf(1000),
        LocalDateTime.now());

    assertThat(payment.getConvertedAmount())
        .isEqualByComparingTo(BigDecimal.ZERO);
}

@Test
@DisplayName("매우 큰 금액 처리")
void largeAmount() {
    BigDecimal largeAmount = new BigDecimal("999999999999.99");
    Payment payment = Payment.createPrepared(1L, "USD",
        largeAmount,
        BigDecimal.valueOf(1000),
        LocalDateTime.now());

    assertThat(payment.getConvertedAmount())
        .isEqualByComparingTo(largeAmount.multiply(BigDecimal.valueOf(1000)));
}
```

## JPA 엔티티와 도메인 테스트

JPA 엔티티도 도메인 오브젝트이지만, 테스트 대상을 명확히 구분해야 한다.

### 도메인 로직 vs 영속성 로직

```java
@Entity
public class Payment {
    @Id @GeneratedValue
    private Long id;

    private Long orderId;
    private String currency;
    private BigDecimal amount;

    // 도메인 로직: DB 없이 테스트 가능
    public boolean isValid(Clock clock) {
        return LocalDateTime.now(clock).isBefore(this.validUntil);
    }

    public BigDecimal calculateTax() {
        return this.amount.multiply(BigDecimal.valueOf(0.1));
    }

    // 영속성 관련 로직: 통합 테스트 필요
    // (save, find, update 등은 Repository 테스트)
}
```

### 도메인 로직 테스트

```java
class PaymentTest {
    @Test
    void isValid() {
        // DB 없이 테스트
        Payment payment = new Payment(...);
        assertThat(payment.isValid(clock)).isTrue();
    }

    @Test
    void calculateTax() {
        // DB 없이 테스트
        Payment payment = new Payment(...);
        assertThat(payment.calculateTax())
            .isEqualByComparingTo(expectedTax);
    }
}
```

### 영속성 로직 테스트

```java
@DataJpaTest
class PaymentRepositoryTest {
    @Autowired
    private PaymentRepository repository;

    @Test
    void save() {
        // DB 필요 (통합 테스트)
        Payment payment = new Payment(...);
        Payment saved = repository.save(payment);
        assertThat(saved.getId()).isNotNull();
    }
}
```

**원칙**: 도메인 로직과 영속성 로직을 분리하여 테스트한다.

## 실전 적용 가이드

### 1. 테스트 작성 순서

```
1. 도메인 오브젝트 테스트 작성
   ↓
2. 도메인 오브젝트 구현
   ↓
3. 서비스 단위 테스트 작성 (Stub 사용)
   ↓
4. 서비스 구현
   ↓
5. 통합 테스트 작성 (필요한 경우만)
```

### 2. 테스트 네이밍 컨벤션

```java
// 예시
@DisplayName("환율 100원으로 100달러 변환 시 10,000원이 된다")
void convertWithExRate100() { }
```

### 3. Given-When-Then 패턴 활용

```java
@Test
void createPrepared() {
    // Given: 테스트 준비
    Clock clock = Clock.fixed(Instant.now(), ZoneId.systemDefault());
    BigDecimal amount = BigDecimal.valueOf(100);
    BigDecimal exRate = BigDecimal.valueOf(1000);

    // When: 테스트 실행
    Payment payment = Payment.createPrepared(
        1L, "USD", amount, exRate, LocalDateTime.now(clock)
    );

    // Then: 검증
    assertThat(payment.getConvertedAmount())
        .isEqualByComparingTo(BigDecimal.valueOf(100000));
}
```

### 4. 테스트 독립성 유지

```java
// 각 테스트는 독립적으로 실행 가능해야 함
class PaymentTest {
    @Test
    void test1() {
        Payment payment = Payment.createPrepared(...);
        // test1 로직
    }

    @Test
    void test2() {
        Payment payment = Payment.createPrepared(...);
        // test2 로직 (test1과 무관)
    }
}

// 테스트 간 의존성 있는 경우
class PaymentTest {
    private Payment payment;  // 공유 상태

    @Test
    void test1() {
        payment = Payment.createPrepared(...);
        // test1이 payment 상태 변경
    }

    @Test
    void test2() {
        // test1의 영향을 받음 (위험!)
    }
}
```

## 결론

도메인 오브젝트 테스트는:

1. **가장 빠르고 안정적인 테스트**이다
2. **비즈니스 로직의 정확성을 보장**한다
3. **외부 의존성이 없어 깨지지 않는다**
4. **리팩토링 시 안전망 역할**을 한다
5. **좋은 설계를 유도**한다
6. **살아있는 문서** 역할을 한다

"최소한 이거라도 만들어라"는 것은 이러한 도메인 오브젝트 테스트가 **모든 테스트의 기반**이 되기 때문이다. 통합 테스트나 E2E 테스트를 작성할 여유가 없더라도, 도메인 오브젝트 테스트만큼은 반드시 작성해야 한다.

현재 프로젝트의 `PaymentTest`는 이러한 원칙을 잘 따르고 있으며, 향후 기능 추가 시에도 동일한 패턴을 유지하는 것이 좋다.
