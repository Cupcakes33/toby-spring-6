# Test와 DI (Dependency Injection)

## 개요

테스트 코드는 DI(의존성 주입)의 필요성과 효과를 가장 명확하게 보여주는 영역이다. 외부 시스템에 의존하는 코드를 테스트하기 위해서는 의존성을 제어할 수 있어야 하며, 이것이 바로 DI가 해결하는 문제다.

## PaymentServiceTest에서의 DI

### 현재 테스트 코드 분석

```java
class PaymentServiceTest {
    @Test
    void prepare() throws IOException {
        PaymentService paymentService = new PaymentService(
            new ExRateProviderStub(BigDecimal.valueOf(100))
        );

        Payment payment = paymentService.prepare(1L, "USD", new BigDecimal(100));

        assertThat(payment.getExRate()).isEqualByComparingTo(BigDecimal.valueOf(100));
        assertThat(payment.getConvertedAmount()).isEqualByComparingTo(BigDecimal.valueOf(10000));
    }
}
```

이 코드에서 **생성자를 통해 `ExRateProviderStub`을 주입**하고 있다. 이것이 바로 DI의 핵심이다.

## DI가 없다면?

### DI 미적용 시나리오

```java
class PaymentService {
    private ExRateProvider provider = new WebApiExRateProvider(); // 강하게 결합

    public Payment prepare(Long orderId, String currency, BigDecimal amount) {
        // WebApiExRateProvider에 의존
        BigDecimal exRate = provider.getExRate(currency);
        // ...
    }
}
```

**문제점:**
1. 테스트 시 실제 외부 API를 호출해야 함
2. 네트워크 연결 필요 → 테스트 환경에서 실패 가능
3. API 응답 시간만큼 테스트가 느려짐
4. API 응답이 바뀌면 테스트 결과도 바뀜 (불안정)
5. API 호출 비용 발생 가능

```java
@Test
void prepare() {
    PaymentService service = new PaymentService(); // WebApiExRateProvider 사용
    Payment payment = service.prepare(1L, "USD", new BigDecimal(100));

    // 실제 환율이 몇인지 알 수 없음
    // assertThat(payment.getExRate()).isEqualTo(???) // 어떤 값을 기대해야 할까?
}
```

### DI 적용 시나리오

```java
class PaymentService {
    private final ExRateProvider provider;

    public PaymentService(ExRateProvider provider) {
        this.provider = provider; // 외부에서 주입
    }

    public Payment prepare(Long orderId, String currency, BigDecimal amount) {
        BigDecimal exRate = provider.getExRate(currency);
        // ...
    }
}
```

**장점:**
1. 테스트에서는 `ExRateProviderStub` 주입
2. 프로덕션에서는 `WebApiExRateProvider` 주입
3. 환율 값을 테스트가 완전히 제어 가능
4. 네트워크 없이 빠르고 안정적인 테스트
5. 외부 시스템과 격리된 단위 테스트 구현

```java
@Test
void prepare() {
    // 환율 1000원으로 고정
    PaymentService service = new PaymentService(
        new ExRateProviderStub(BigDecimal.valueOf(1000))
    );

    Payment payment = service.prepare(1L, "USD", new BigDecimal(100));

    // 예상 값을 정확히 알 수 있음
    assertThat(payment.getExRate()).isEqualByComparingTo(BigDecimal.valueOf(1000));
    assertThat(payment.getConvertedAmount()).isEqualByComparingTo(BigDecimal.valueOf(100000));
}
```

## DI의 구성 요소

### 1. 추상화 (Interface)

```java
package org.app.tobyspring.payment;

public interface ExRateProvider {
    BigDecimal getExRate(String currency) throws IOException;
}
```

- PaymentService가 의존하는 **추상화 계층**
- payment 패키지에 위치 → DIP 준수
- 구현 방식을 강제하지 않음

### 2. 실제 구현체 (Production)

```java
package org.app.tobyspring.exRate;

public class WebApiExRateProvider implements ExRateProvider {
    @Override
    public BigDecimal getExRate(String currency) throws IOException {
        // 실제 API 호출 로직
        URL url = new URL("https://api.exchangerate.com/...");
        // ...
    }
}
```

- 실제 프로덕션에서 사용될 구현체
- exRate 패키지에 위치
- payment 패키지를 의존 (DIP)

### 3. 테스트 대역 (Test Double - Stub)

```java
package org.app.tobyspring.payment;

public class ExRateProviderStub implements ExRateProvider {
    private BigDecimal exRate;

    public ExRateProviderStub(BigDecimal exRate) {
        this.exRate = exRate;
    }

    @Override
    public BigDecimal getExRate(String currency) {
        return this.exRate; // 고정된 값 반환
    }
}
```

- 테스트 전용 구현체
- 외부 의존성 제거
- 테스트가 환율 값을 완전히 제어

### 4. 의존성 주입 (Injection)

```java
// 테스트 환경
PaymentService service = new PaymentService(
    new ExRateProviderStub(BigDecimal.valueOf(1000))
);

// 프로덕션 환경 (Spring 없이 수동)
PaymentService service = new PaymentService(
    new WebApiExRateProvider()
);

// 프로덕션 환경 (Spring 사용 시)
@Service
public class PaymentService {
    private final ExRateProvider provider;

    @Autowired // Spring이 자동으로 주입
    public PaymentService(ExRateProvider provider) {
        this.provider = provider;
    }
}
```

## DIP와의 관계

### 의존성 방향

```
┌─────────────────┐
│ PaymentService  │ (High-level policy)
└────────┬────────┘
         │ depends on
         ↓
┌─────────────────┐
│ ExRateProvider  │ (Interface/Abstraction)
└────────┬────────┘
         ↑ implements
    ┌────┴────┬────────────┐
    │         │            │
WebApiExRate  Cached   ExRateProvider
Provider      ExRate   Stub
              Provider
(Production)  (Prod)   (Test)
```

**핵심 원칙:**
- PaymentService는 구체 클래스가 아닌 **인터페이스에 의존**
- 인터페이스가 payment 패키지에 있음 → **DIP 적용**
- 구현체들이 인터페이스를 구현 → **의존성 방향 역전**

### 제어의 역전 (IoC - Inversion of Control)

**전통적 방식 (제어권: PaymentService)**
```java
class PaymentService {
    public Payment prepare(...) {
        ExRateProvider provider = new WebApiExRateProvider(); // 직접 생성
        // PaymentService가 어떤 구현체를 사용할지 결정
    }
}
```

**IoC 적용 (제어권: 외부)**
```java
class PaymentService {
    private final ExRateProvider provider;

    public PaymentService(ExRateProvider provider) {
        this.provider = provider; // 외부에서 주입받음
    }
}

// 제어권이 외부(테스트 코드, Spring 컨테이너 등)로 이동
PaymentService service = new PaymentService(
    new ExRateProviderStub(...) // 외부에서 결정
);
```

## 테스트 대역의 종류

### 1. Stub (현재 사용 중)

```java
public class ExRateProviderStub implements ExRateProvider {
    private BigDecimal exRate;

    public ExRateProviderStub(BigDecimal exRate) {
        this.exRate = exRate;
    }

    @Override
    public BigDecimal getExRate(String currency) {
        return this.exRate; // 미리 정해진 값 반환
    }
}
```

**특징:**
- 미리 준비된 답변을 반환
- 테스트가 예측 가능한 결과를 기대할 때 사용

### 2. Mock (향후 사용 가능)

```java
@Test
void prepare() {
    ExRateProvider mockProvider = mock(ExRateProvider.class);
    when(mockProvider.getExRate("USD")).thenReturn(BigDecimal.valueOf(1000));

    PaymentService service = new PaymentService(mockProvider);
    Payment payment = service.prepare(1L, "USD", new BigDecimal(100));

    // 호출 검증 가능
    verify(mockProvider, times(1)).getExRate("USD");
}
```

**특징:**
- 메서드 호출 여부, 횟수, 순서 검증 가능
- 더 복잡한 상호작용 테스트에 유용

### 3. Fake (실제와 유사한 단순 구현)

```java
public class InMemoryExRateProvider implements ExRateProvider {
    private Map<String, BigDecimal> rates = new HashMap<>();

    public void setRate(String currency, BigDecimal rate) {
        rates.put(currency, rate);
    }

    @Override
    public BigDecimal getExRate(String currency) {
        return rates.getOrDefault(currency, BigDecimal.ONE);
    }
}
```

**특징:**
- 실제 동작하지만 단순화된 구현
- 여러 테스트에서 재사용 가능

## 실전 적용 시나리오

### 시나리오 1: 다양한 환율로 테스트

```java
private static void testConvertedAmount(BigDecimal exRate, BigDecimal convertedExRate) {
    PaymentService paymentService = new PaymentService(
        new ExRateProviderStub(exRate) // 환율을 파라미터로 받음
    );

    Payment payment = paymentService.prepare(1L, "USD", new BigDecimal(100));

    assertThat(payment.getExRate()).isEqualByComparingTo(exRate);
    assertThat(payment.getConvertedAmount()).isEqualByComparingTo(convertedExRate);
}

@Test
void multipleExRates() {
    testConvertedAmount(BigDecimal.valueOf(1000), BigDecimal.valueOf(100000));
    testConvertedAmount(BigDecimal.valueOf(1200), BigDecimal.valueOf(120000));
    testConvertedAmount(BigDecimal.valueOf(800), BigDecimal.valueOf(80000));
}
```

**DI 덕분에:**
- 같은 테스트 로직을 다양한 환율로 반복 실행
- 외부 API 없이 모든 경우의 수 테스트 가능

### 시나리오 2: 예외 상황 테스트

```java
public class ExRateProviderErrorStub implements ExRateProvider {
    @Override
    public BigDecimal getExRate(String currency) throws IOException {
        throw new IOException("API connection failed");
    }
}

@Test
void handleApiError() {
    PaymentService service = new PaymentService(
        new ExRateProviderErrorStub()
    );

    assertThatThrownBy(() ->
        service.prepare(1L, "USD", new BigDecimal(100))
    ).isInstanceOf(IOException.class);
}
```

**DI 덕분에:**
- 네트워크 에러 상황을 시뮬레이션
- 실제 API 장애를 기다릴 필요 없음

### 시나리오 3: 성능 테스트

```java
@Test
void performanceTest() {
    // Stub은 즉시 응답하므로 순수 비즈니스 로직 성능만 측정
    PaymentService service = new PaymentService(
        new ExRateProviderStub(BigDecimal.valueOf(1000))
    );

    long start = System.currentTimeMillis();
    for (int i = 0; i < 10000; i++) {
        service.prepare((long) i, "USD", new BigDecimal(100));
    }
    long duration = System.currentTimeMillis() - start;

    assertThat(duration).isLessThan(1000); // 1초 이내
}
```

**DI 덕분에:**
- 외부 API 호출 시간 제외
- 순수 비즈니스 로직 성능만 측정

## DI의 이점 정리

### 1. 테스트 가능성 (Testability)
- 외부 의존성을 제어 가능한 테스트 대역으로 교체
- 빠르고 안정적인 단위 테스트 작성 가능
- 다양한 시나리오와 예외 상황 테스트 용이

### 2. 유연성 (Flexibility)
- 런타임에 다른 구현체로 교체 가능
- 새로운 ExRateProvider 추가 시 PaymentService 수정 불필요
- 환경별로 다른 구현체 사용 가능 (개발/테스트/운영)

### 3. 단일 책임 원칙 (SRP)
- PaymentService는 결제 로직에만 집중
- 환율 조회는 ExRateProvider가 담당
- 관심사의 분리 (Separation of Concerns)

### 4. 확장성 (Extensibility)
- 새로운 환율 제공 방식 추가 용이
- CachedExRateProvider, FixedExRateProvider 등 자유롭게 구현
- 기존 코드 수정 없이 확장 가능 (Open-Closed Principle)

## Spring Framework와의 연결

현재는 수동으로 DI를 수행하고 있지만, Spring을 사용하면 자동화할 수 있다.

### 수동 DI (현재)

```java
// 테스트에서 직접 주입
PaymentService service = new PaymentService(
    new ExRateProviderStub(BigDecimal.valueOf(1000))
);

// 프로덕션에서도 직접 주입
PaymentService service = new PaymentService(
    new WebApiExRateProvider()
);
```

### Spring DI (자동화)

```java
@Service
public class PaymentService {
    private final ExRateProvider provider;

    @Autowired
    public PaymentService(ExRateProvider provider) {
        this.provider = provider; // Spring이 자동 주입
    }
}

@Configuration
public class AppConfig {
    @Bean
    public ExRateProvider exRateProvider() {
        return new WebApiExRateProvider(); // 프로덕션 구현체
    }
}

@TestConfiguration
public class TestConfig {
    @Bean
    public ExRateProvider exRateProvider() {
        return new ExRateProviderStub(BigDecimal.valueOf(1000)); // 테스트 구현체
    }
}
```

**Spring의 역할:**
- 객체 생성과 주입을 자동화
- 환경별로 다른 설정 적용 가능
- 싱글톤 등 생명주기 관리

## 결론

현재 PaymentServiceTest는 다음을 증명한다:
1. ExRateProvider 인터페이스를 통한 추상화
2. 생성자를 통한 의존성 주입
3. 테스트 대역(Stub)을 통한 의존성 제어
4. DIP 원칙 준수를 통한 유연한 설계

이러한 패턴들이 결합되어 외부 API 없이도 안정적이고 빠른 테스트를 가능하게 한다.